***************************************
Peak alignment by dynamic programming
***************************************

.. contents:: Table of Contents

PyMS provides functions to align GC-MS peaks by dynamic programming
[1]_.  The peak alignment by dynamic programming uses both peak
apex retention time and mass spectra.  This information is determined from the
raw GC-MS data by applying a series of processing steps to produce data that
can then be aligned and used for statistical analysis.  The details are
described in this chapter.

Preparation of multiple experiments for peak alignment by dynamic programming
=============================================================================

Creating an Experiment
-------------------------

.. note:: This example is in `pyms-test/60 <../pyms-test/60/60.html>`__

Before aligning peaks from multiple experiments, the peak objects need to be
created and encapsulated into PyMS experiment objects. During this process
it is often useful to pre-process the peaks in some way, for example to
null certain m/z channels and/or to select a certain retention time range.

To capture the data and related information prior to peak alignment, an
:py:meth:`Experiment <pyms.Experiment.Class.Experiment>`
object is used. The :py:meth:`Experiment <pyms.Experiment.Class.Experiment>`
object is defined in :py:meth:`pyms.Experiment.Class <pyms.Experiment.Class>`.

The procedure is to proceed as described in the previous chapter. Namely: read
a file; bin the data into fixed mass values; smooth the data; remove the
baseline; deconvolute peaks; filter the peaks; set the mass range; remove
uninformative ions; and estimate peak areas. The process is given in the
following program listing.

.. code-block:: python
   :linenos:

    import sys, os

    from pyms.GCMS.IO.ANDI.Function import ANDI_reader
    from pyms.GCMS.Function import build_intensity_matrix_i
    from pyms.Noise.SavitzkyGolay import savitzky_golay
    from pyms.Baseline.TopHat import tophat
    from pyms.Peak.Class import Peak
    from pyms.Peak.Function import peak_sum_area

    from pyms.Deconvolution.BillerBiemann.Function import BillerBiemann, \
        rel_threshold, num_ions_threshol

    # deconvolution and peak list filtering parameters
    points = 9; scans = 2; n = 3; t = 3000; r = 2;

    andi_file = "data/a0806_077.cdf"

    data = ANDI_reader(andi_file)

    # integer mass
    im = build_intensity_matrix_i(data)

    # get the size of the intensity matrix
    n_scan, n_mz = im.get_size()

    # smooth data
    for ii in range(n_mz):
        ic = im.get_ic_at_index(ii)
        ic1 = savitzky_golay(ic)
        ic_smooth = savitzky_golay(ic1)
        ic_base = tophat(ic_smooth, struct="1.5m")
        im.set_ic_at_index(ii, ic_base)

    # do peak detection on pre-trimmed data

    # get the list of Peak objects
    pl = BillerBiemann(im, points, scans)

    # trim by relative intensity
    apl = rel_threshold(pl, r)

    # trim by threshold
    peak_list = num_ions_threshold(apl, n, t)

    print "Number of Peaks found:", len(peak_list)

    # ignore TMS ions and set mass range
    for peak in peak_list:
        peak.crop_mass(50,540)
        peak.null_mass(73)
        peak.null_mass(147)
        # find area
        area = peak_sum_area(im, peak)
        peak.set_area(area)


The resulting list of peaks can now be stored as an
:py:meth:`Experiment <pyms.Experiment.Class.Experiment>` object.

.. code-block:: python
   :linenos:
   :lineno-start: 57

    from pyms.Experiment.Class import Experiment
    from pyms.Experiment.IO import store_expr

    # create an experiment
    expr = Experiment("a0806_077", peak_list)
    
    # set time range for all experiments
    expr.sele_rt_range(["6.5m", "21m"])
    
    store_expr("output/a0806_077.expr", expr)

Once an experiment has been defined, it is possible to limit the peak list to
a desired range using
:py:meth:`sele_rt_range() <pyms.Experiment.Class.Experiment.sele_rt_range>`.
The resulting experiment object can then be stored for later alignment.

Multiple Experiments
---------------------------

.. note:: This example is in `pyms-test/61a <../pyms-test/61a/61a.html>`__

This example considers the preparation of three GC-MS experiments for peak
alignment. The experiments are named ``a0806_077``, ``a0806_078``, ``a0806_079``,
and represent separate GC-MS sample runs from the same biological sample.

The procedure is the same as above, and repeated for each experiment.  For
example:

.. code-block:: python
   :linenos:

    # define path to data files
    base_path = "data/"

    # define experiments to process
    expr_codes = [ "a0806_077", "a0806_078", "a0806_079" ]

    # loop over all experiments
    for expr_code in expr_codes:

        print "Processing", expr_code

        # define the names of the peak file and the corresponding ANDI-MS file
        andi_file = os.path.join(base_path, expr_code + ".cdf")
    ...

    ...
        # create an experiment
        expr = Experiment(expr_code, peak_list)

        # use same time range for all experiments
        expr.sele_rt_range(["6.5m", "21m"])

        store_expr("output/"+expr_code+".expr", expr)

.. note:: This example is in `pyms-test/61b <../pyms-test/61b/61b.html>`__

The previous set of data all belong to the same experimental condition.  That
is, they represent one group and any comparison between the data is a within
group comparison. For the original experiment, another set of GC-MS data was
collected for a different experimental condition.  This group must also be
stored as a set of experiments, and can be used for between group comparison.

The experiments are named ``a0806_140``, ``a0806_141``, ``a0806_142``, and are
processed and stored as above (see pyms-test/61b).

Dynamic programming alignment of peak lists from multiple experiments
========================================================================

* This example is in pyms-test/62
* This example uses the subpackage pyms.Peak.List.DPA, which in turn uses the Python package 'Pycluster'.  For 'Pycluster' installation instructions see the Section \ref{subsec:pycluster}

In this example the experiments ``a0806_077``, ``a0806_078``, and ``a0806_079``
prepared in pyms-test/61a will be aligned, and therefore the script
pyms-test/61a/proc.py must be run first, to create the files
``a0806_077.expr``, ``a0806_078.expr``, ``a0806_079.expr`` in the directory
pyms-test/61a/output/. These files contain the post-processed peak lists
from the three experiments.

A script for running the dynamic programming alignment on these experiments is
given below.

.. code-block:: python
   :linenos:

    """proc.py
    """

    import sys, os

    from pyms.Experiment.IO import load_expr
    from pyms.Peak.List.DPA.Class import PairwiseAlignment
    from pyms.Peak.List.DPA.Function import align_with_tree, exprl2alignment

    # define the input experiments list
    exprA_codes = [ "a0806_077", "a0806_078", "a0806_079" ]

    # within replicates alignment parameters
    Dw = 2.5  # rt modulation [s]
    Gw = 0.30 # gap penalty

    # do the alignment
    print 'Aligning expt A'
    expr_list = []
    expr_dir = "../61a/output/"
    for expr_code in exprA_codes:
        file_name = os.path.join(expr_dir, expr_code + ".expr")
        expr = load_expr(file_name)
        expr_list.append(expr)
    F1 = exprl2alignment(expr_list)
    T1 = PairwiseAlignment(F1, Dw, Gw)
    A1 = align_with_tree(T1, min_peaks=2)

    A1.write_csv('output/rt.csv', 'output/area.csv')

The script reads the experiment files from the directory where they were stored
(``61a/output``), and creates a list of the loaded ``Experiment`` objects.
Each experiment object is converted into an ``Alignment`` object with {\tt
exprl2alignment()``. In this example, there is only one experimental condition
so the alignment object is only for within group alignment (this special case
is called 1-alignment). The variable F1 is a Python list containing three
alignment objects.

The pairwise alignment is then performed.  The parameters for the alignment by
dynamic programming are: Dw, the retention time modulation in seconds; and Gw,
the gap penalty.  These parameters are explained in detail in
[1]_.
:py:meth:`PairwiseAlignment() <pyms.Peak.List.DPA.Class.PairwiseAlignment>`, defined in
:py:meth:`pyms.Peak.List.DPA.Class <pyms.Peak.List.DPA.Class>`
is a class that calculates the similarity between all peaks in
one sample with those of another sample.  This is done for all
possible pairwise alignments (2-alignments). The output of
:py:meth:`PairwiseAlignment() <pyms.Peak.List.DPA.Class.PairwiseAlignment>`,
(``T1``) is an object which contains the dendrogram tree that
maps the similarity relationship between the input 1-alignments,
and also 1-alignments themselves.

The function :py:meth:`align_with_tree() <pyms.Peak.List.DPA.Class.align_with_tree>`
takes the object T1 and aligns the individual alignment objects according to
the guide tree.  In this example, the individual alignments are
three 1-alignments, and the function
:py:meth:`align_with_tree() <pyms.Peak.List.DPA.Class.align_with_tree>`
first creates a 2-alignment from the two most similar 1-alignments
and then adds the third 1-alignment to this to create a 3-alignment.
The parameter ``min_peaks=2`` specifies that any peak column of the
data matrix that has less than two peaks in the final alignment
will be dropped.  This is useful to clean up the data matrix of
accidental peaks that are not truly observed over the set of replicates.

Finally, the resulting 3-alignment is saved by writing alignment tables
containing peak retention times (``rt1.csv``) and the corresponding peak areas
(`area1.csv'). These two files are plain ASCII files is CSV format, and are
saved in the directory ``62/output/``.

The file ``area1.csv`` contains the data matrix where the corresponding peaks are
aligned in the columns and each row corresponds to an experiment. The file
``rt1.csv`` is useful for manually inspecting the alignment in some GUI driven
program.

Between-state alignment of peak lists from multiple experiments
==================================================================

.. note:: This example is in `pyms-test/63 <../pyms-test/63/63.html>`__

In the previous example the list of peaks were aligned within a single
experiment with multiple replicates ("within-state alignment").  In practice,
it is of more interest to compare the two experimental states. In a typical
experimental setup there can be multiple replicate experiments on each
experimental state or condition. To analyze the results of such an experiment
statistically, the list of peaks need to be aligned within each
experimental state and also between the states. The result of such an alignment
would be the data matrix of integrated peak areas. The data matrix contains
a row for each sample and the number of columns is determined by
the number of unique peaks (metabolites) detected in all the experiments.

In principle, all experiments could be aligned across conditions and
replicates in the one process. However, a more robust approach is to first align
experiments within each set of replicates (within-state
alignment), and then to align the resulting alignments (between-state
alignment) [1]_.

This example demonstrates how the peak lists from two cell states are
aligned. The cell state, A, consisting of three experiments aligned in
``pyms-test/61a`` (``a0806_077``, ``a0806_078``, ``a0806_079``) and cell state,
B, consisting of three experiments aligned in ``pyms-test/61b`` (``a0806_140``,
``a0806_141``, and ``a0806_142``).

The between group alignment can be performed by the following alignment
commands.

.. code-block:: python
   :linenos:

   # between replicates alignment parameters
   Db = 10.0 # rt modulation
   Gb = 0.30 # gap penalty

   print 'Aligning input {1,2``'
   T9 = PairwiseAlignment([A1,A2], Db, Gb)
   A9 = align_with_tree(T9)

   A9.write_csv('output/rt.csv', 'output/area.csv')

where ``A1`` and ``A2`` are the results of the within group alignments
(as above) for group A and B, respectively.

In this example the retention time tolerance for between-state alignment is
greater compared to the retention time tolerance for the within-state alignment
as we expect less fidelity in retention times between them.  The same functions
are used for the within-state and between-state alignment. The result of the
alignment is saved to a file as the area and retention time matrices (described
above).

Common Ion Area Quantitation
================================
.. note:: This example is in `pyms-test/41 <../pyms-test/41/41.html>`__

The ``area.csv`` file produced in the preceding section lists the
total area of each peak in the alignment. The total area is the sum of
the areas of each of the individual ions in the peak. While this approach
produces broadly accurate results, it can result in errors where
neighbouring peaks or unfiltered noise add to the peak in some way.

One alternative to this approach is to pick a single ion which is
common to a particular peak (compound), and to report only the area of this ion
for each occurrence of that peak in the alignment. Using the method
:py:meth:`common_ion() <pyms.Peak.List.DPA.Class.common_ion>`
of the PyMS class Alignment, PyMS can select an ion for
each aligned peak which is both abundant and occurs most often
for that peak. We call this the 'Common Ion Algorithm' (CIA).

To implement this in PyMS, it is essential that the individual ion
areas have been set (see section \ref{sec:individual-ion-areas``).


Using the Common Ion Algorithm
----------------------------------

When using the CIA for area quantitation, a different method of the
class Alignment is used to write the area matrix;
:py:meth:`write_common_ion_csv() <pyms.Peak.List.DPA.Class.write_common_ion_csv>`.
This requires a list of the common ions for each peak in the alignment.
This list is generated using the Alignment class method
:py:meth:`common_ion() <pyms.Peak.List.DPA.Class.common_ion>`.

Continuing from the previous example, the following invokes common ion
filtering on previously created alignment object 'A9':

    >>> common_ion_list = A9.common_ion()

The variable 'common_ion_list' is a list of the common ion for each
peak in the alignment. This list is the same length as the
alignment. To write peak areas using common ion quantitation:

   >>> A9.write_common_ion_csv('output/area_common_ion.csv',common_ion_list)

References
============

.. [1] Robinson MD, De Souza DP, Keen WW, Saunders EC, McConville MJ, Speed TP, and Likic VA. A dynamic programming approach for the alignment of signal peaks in multiple gas chromatography-mass spectrometry experiments. `BMC Bioinformatics`, 8:419, 2007

